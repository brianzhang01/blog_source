---
title: Random Graphs and Giant Components
author: Brian Zhang
date: '2018-06-04'
slug: random-graphs-and-giant-components
categories: []
tags: []
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This post will introduce some of the ideas behind random graphs, a very exciting area of current probability research. As has been a theme in my posts so far, I try to emphasize a reproducible, computational example. In this case, we'll be looking at the "giant component" and how that arises in random graphs.

There's a lot more than this example that I find exciting, so I've deferred a longer discussion on random graphs to the end of this post, with a lot of references for the interested reader.

In addition to code that sits inside the R markdown file for this post, I also wrote some C++ code to generate the more time-intensive examples. That repository is accessible on GitHub [here](https://github.com/brianzhang01/giant_demo).

## Introduction: random graphs

Someone recently asked me at a pub what it takes to get a probability distribution named after you. Are new distributions still being discovered today?

I answered that we usually think of probability distributions as over the one-dimensional real line, for which most distributions have been with us for perhaps a century.^[See for instance, my previous post. There exist some interesting counterexamples, like the [Marchenko-Pastur](https://en.wikipedia.org/wiki/Marchenko%E2%80%93Pastur_distribution) (1960s) and [Tracy-Widom](https://en.wikipedia.org/wiki/Tracy%E2%80%93Widom_distribution) (1990s) distributions.] However, one can study the probability distributions of all sorts of abstract objects -- from a deck of cards to randomly broken sticks -- and many of these areas remain ripe for discovery.

The field of random graphs is one such area. Recall from college-level math or computer science that an undirected graph is a collection of *vertices* (also called nodes), with some pairs of vertices connected by *edges*. Originally, those working in graph theory focused on proving many deterministic properties of graphs. For instance, let the *degree* of a vertex be the number of other vertices it is connected to. Then the [handshake lemma](https://en.wikipedia.org/wiki/Handshaking_lemma) says that the sum of all the degrees is always an even number (proof omitted here).

By contrast, the field of random graphs is interested in probabilistic properties of graphs given a random process for generating them. Here's the simplest type of random graph that is studied. Fix a positive integer $N$ and a probability $p$ between 0 and 1. Given $N$ vertices, there are $\binom{N}{2}$ possible edges between them, so choose to connect each edge with independent probability $p$ (e.g. by flipping a biased coin $\binom{N}{2}$ times). Voila! You have generated a random graph. As long as $p$ is not 0 or 1, this process can generate any undirected graph on $N$ vertices. However, some configurations will be more probable while others are less probable. This probability distribution over undirected graphs, or equivalently the generative process described, are called the Erdos-Renyi random graph with parameters $N$ and $p$.^[For a more nuanced discussion of the naming of this model, see the last section of this post.]

Since each edge is sampled independently, we can derive a result on the total number of edges in the graph: it follows a $\mbox{Binomial}(\binom{N}{2}, p)$ distribution. Similarly, if we consider a single vertex, there are $N - 1$ possible edges that involve that vertex. Since each is sampled independently, the degree of each vertex follows a $\mbox{Binomial}{N-1, p}$ distribution. The expression $(N-1)p$ will thus be the mean degree of a vertex.

## They Might Be Giants



## An animation

```{r graph-functions, warning=FALSE, message=FALSE}
library(igraph)

make_graph = function(n, p, seed=1) {
  set.seed(seed)
  probs = runif(n*(n-1)/2)
  k = 1
  edges = NULL
  for (i in 1:(n-1)) {
    for (j in (i+1):n) {
      if (probs[k] < p) {
        edges = c(edges, c(i, j))
      }
      k = k + 1
    }
  }
  return(graph(edges=edges, n=n, directed=F))
}

plot_graph = function(g, main="", layout=layout_in_circle, vsize=5) {
  comp = components(g)
  max_comp = (comp$membership == which.max(comp$csize))
  special = ifelse(max_comp, "orange", "blue")
  plot(g, layout=layout, vertex.size=vsize, vertex.label=NA,
       vertex.color=special, main=main)
}
```

For n = 50:
```{r graph-viz-50, fig.show="animate"}
n = 50
mean_degree = c(seq(0, 4, 0.25))
max_size = NULL
for (i in 1:length(mean_degree)) {
  d = mean_degree[i]
  p = d / (n-1)
  g = make_graph(n, p)
  max_size[i] = max(components(g)$csize)
  
  layout(matrix(c(1, 2), 1), c(4, 3))
  plot_graph(
    g, layout=layout_in_circle,
    main=paste0("p*(n-1)=", sprintf("%.2f", d), ", max_size=", max_size[i]))
  plot(c(0, max(mean_degree)), c(0, n), type="n",
       main="Summary", xlab="mean_degree", ylab="max_size")
  lines(mean_degree[1:i], max_size, type="o", pch=19)
}
```

For n = 500:
```{r graph-viz-500, fig.show="animate"}
n = 500
mean_degree = c(seq(0, 6, 0.25))
max_size = NULL
for (i in 1:length(mean_degree)) {
  d = mean_degree[i]
  p = d / (n-1)
  g = make_graph(n, p)
  max_size[i] = max(components(g)$csize)
  
  layout(matrix(c(1, 2), 1), c(4, 3))
  plot_graph(
    g, layout=layout_on_sphere,
    main=paste0("p*(n-1)=", sprintf("%.2f", d), ", max_size=", max_size[i]))
  plot(c(0, max(mean_degree)), c(0, n), type="n",
       main="Summary", xlab="mean_degree", ylab="max_size")
  lines(mean_degree[1:i], max_size, type="o", pch=19)
}
```


So my idea was to repeat the above example multiple times. For each value of $n$, I was interested in many separate instantiations (corresponding to different random seeds), and I wanted to observe how the behavior changes as $n$ increases. While `igraph` would have sufficed for this, I decided to write my own [C++ implementation](https://github.com/brianzhang01/giant_demo). This allowed me to add a small algorithmic trick, the union-find data structure, to query the size of the giant component, which is faster than doing a breadth-first / depth-first search through the graph.

## Results for moderate n
<img src="/data/giant_summary_n50.png" height="500" />

<img src="/data/giant_summary_n500.png" height="500" />

## Theory, Part Two


## Results for n = 10,000
<img src="/data/giant_summary_n10000.png" height="500" /> <img src="/data/giant_summary_n10000_small.png" height="500" /> <img src="/data/giant_summary_n10000_big.png" height="500" />

## Results for n = 1,000,000
<img src="/data/giant_summary_n1000000.png" height="500" /> <img src="/data/giant_summary_n1000000_small.png" height="500" /> <img src="/data/giant_summary_n1000000_big.png" height="500" />

## Conclusion and Bibliography

That concludes my example of analyzing the largest component size in Erdos-Renyi random graphs. However, as I mentioned at the start of this post, this only scratches the surface, and there's a lot more to dig into in terms of the mathematical details, history, and current work in this area. Here's my attempt at a survey of what else is out there.

**Books.**

**Proofs and stuff.** Erdos, Renyi, Gilbert. Chronology and naming

**Beyond the Erdos-Renyi model.** Other models like Barabasi-Albert (originally discovered by Price in 1965), general idea of scale-free networks. I am thankful to Juho Lee at Oxford for introducing me to paper on inhomogeneous random graphs.

**Other critical behavior.** Physics analogs. Work by Skerman and McDiarmid that first introduced me to this area.

**Software and network visualization.**

**Acknowledgments.** As mentioned earlier, I was first exposed to the surprising critical behavior of random graphs by a lecture by Fiona Skerman in November 2017. In preparing this post, the `igraph` package and Ognyanova's tutorial proved very helpful. Finally, Juho Lee, Ryan Lee, and Ruth Fong provided some useful ideas which influenced my final presentation.
