---
title: Random Graphs and Giant Components
author: Brian Zhang
date: '2018-06-04'
slug: random-graphs-and-giant-components
categories: []
tags: []
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

This post will introduce some of the ideas behind random graphs, a very exciting area of current probability research. As has been a theme in my posts so far, I try to emphasize a reproducible, computational example. In this case, we'll be looking at the "giant component" and how that arises in random graphs.

There's a lot more than this example that I would like to talk about, so I've deferred a longer discussion on random graphs to the end of this post, with a lot of references for the interested reader.

In addition to code that sits inside the R markdown file for this post, I also wrote some C++ code to generate the more time-intensive examples. That repository is accessible on GitHub [here](https://github.com/brianzhang01/giant_demo).

## The theory

## An animation

```{r graph-functions, warning=FALSE, message=FALSE}
library(igraph)

make_graph = function(n, p, seed=1) {
  set.seed(seed)
  probs = runif(n*(n-1)/2)
  k = 1
  edges = NULL
  for (i in 1:(n-1)) {
    for (j in (i+1):n) {
      if (probs[k] < p) {
        edges = c(edges, c(i, j))
      }
      k = k + 1
    }
  }
  return(graph(edges=edges, n=n, directed=F))
}

plot_graph = function(g, main="", layout=layout_in_circle, vsize=5) {
  comp = components(g)
  max_comp = (comp$membership == which.max(comp$csize))
  special = ifelse(max_comp, "orange", "blue")
  plot(g, layout=layout, vertex.size=vsize, vertex.label=NA,
       vertex.color=special, main=main)
}
```

For n = 50:
```{r graph-viz-50, fig.show="animate"}
n = 50
mean_degree = c(seq(0, 4, 0.25))
for (d in mean_degree) {
  p = d / (n-1)
  g = make_graph(n, p)
  max_comp_size = max(components(g)$csize)
  plot_graph(
    g, layout=layout_in_circle,
    main=paste0("p*(n-1)=", sprintf("%.2f", d), ", max_component=", max_comp_size))
}
```

For n = 500:
```{r graph-viz-500, fig.show="animate"}
n = 500
mean_degree = c(seq(0, 6, 0.25))
for (d in mean_degree) {
  p = d / (n-1)
  g = make_graph(n, p)
  max_comp_size = max(components(g)$csize)
  plot_graph(
    g, layout=layout_on_sphere,
    main=paste0("p*(n-1)=", sprintf("%.2f", d), ", max_component=", max_comp_size))
}
```


So my idea was to repeat the above example multiple times. For each value of $n$, I was interested in many separate instantiations (corresponding to different random seeds), and I wanted to observe how the behavior changes as $n$ increases. While `igraph` would have sufficed for this, I decided to write my own [C++ implementation](https://github.com/brianzhang01/giant_demo). This allowed me to add a small algorithmic trick, the union-find data structure, to query the size of the giant component, which is faster than doing a breadth-first / depth-first search through the graph.

## Results for moderate n
<img src="/data/giant_summary_n50.png" height="500" />

<img src="/data/giant_summary_n500.png" height="500" />

## Results for n = 10,000
<img src="/data/giant_summary_n10000.png" height="500" /> <img src="/data/giant_summary_n10000_small.png" height="500" /> <img src="/data/giant_summary_n10000_big.png" height="500" />

## Results for n = 1,000,000
<img src="/data/giant_summary_n1000000.png" height="500" /> <img src="/data/giant_summary_n1000000_small.png" height="500" /> <img src="/data/giant_summary_n1000000_big.png" height="500" />


Some text
